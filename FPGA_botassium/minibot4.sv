
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module minibot4(

	//////////// CLOCK //////////
	CLOCK_50,

	//////////// LED //////////
	LED,

	//////////// KEY //////////
	KEY,

	//////////// SDRAM //////////
	DRAM_ADDR,
	DRAM_BA,
	DRAM_CAS_N,
	DRAM_CKE,
	DRAM_CLK,
	DRAM_CS_N,
	DRAM_DQ,
	DRAM_DQM,
	DRAM_RAS_N,
	DRAM_WE_N,

	//////////// Accelerometer //////////
	G_SENSOR_CS_N,
	G_SENSOR_INT,
	I2C_SCLK,
	I2C_SDAT,

	//////////// 2x13 GPIO Header //////////
	GPIO_2,
	GPIO_2_IN,

	//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
	GPIO_0_PI,
	GPIO_0_PI_IN,

	//////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
	GPIO_1,
	GPIO_1_IN 
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input 		          		CLOCK_50;

//////////// LED //////////
output		     [7:0]		LED;

//////////// KEY //////////
input 		     [1:0]		KEY;

//////////// SDRAM //////////
output		    [12:0]		DRAM_ADDR;
output		     [1:0]		DRAM_BA;
output		          		DRAM_CAS_N;
output		          		DRAM_CKE;
output		          		DRAM_CLK;
output		          		DRAM_CS_N;
inout 		    [15:0]		DRAM_DQ;
output		     [1:0]		DRAM_DQM;
output		          		DRAM_RAS_N;
output		          		DRAM_WE_N;

//////////// Accelerometer //////////
output		          		G_SENSOR_CS_N;
input 		          		G_SENSOR_INT;
output		          		I2C_SCLK;
inout 		          		I2C_SDAT;

//////////// 2x13 GPIO Header //////////
inout 		    [12:0]		GPIO_2;
input 		     [2:0]		GPIO_2_IN;

//////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
inout 		    [33:0]		GPIO_0_PI;
input 		     [1:0]		GPIO_0_PI_IN;

//////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
inout 		    [33:0]		GPIO_1;
input 		     [1:0]		GPIO_1_IN;


//=======================================================
//  REG/WIRE declarations
//=======================================================

	logic clk2, clock, clk;
	logic [31:0] reduce, reduce2, reduce3;
	assign reduce = 32'd1000000;
	assign reduce2 = 32'd100000;
	assign reduce3 = 32'd5;
	logic read;
	logic odoAL, odoBL, odoAR, odoBR;
	logic[31:0] wheel_left, wheel_right, odo_left, odo_right, microswitchL, microswitchR, codeAL, codeBL, codeAR, codeBR;
	assign codeAL = GPIO_1[33];
	assign codeBL = GPIO_1[32];
	assign codeAR = GPIO_1[30];
	assign codeBR = GPIO_1[31];
	assign odoAR = GPIO_1[13];
	assign odoBR = GPIO_1[15];
	assign odoAL = GPIO_1[16];
	assign odoBL = GPIO_1[17];
	assign microswitchL = GPIO_1[21];
	assign microswitchR = GPIO_1[23];
	logic [31:0] distance1, distance2, distance3, distance4;

	logic echo1, trigger1, echo2, trigger2, echo3, trigger3, echo4, trigger4;
	assign echo1 = GPIO_1[9];
	assign trigger1 = GPIO_1[11];
	assign echo2 = GPIO_1[2];
	assign trigger2 = GPIO_1[4];
	assign echo3 =  GPIO_1[7];
	assign trigger3 = GPIO_1[6];
	assign echo4 = GPIO_1[3];
	assign trigger4 = GPIO_1[5];


//=======================================================
//  Structural coding
//=======================================================

//=======================================================
//  SPI
//=======================================================

	logic 			spi_clk, spi_cs, spi_mosi, spi_miso, CLOCK,clk3, writeE;
	logic [31:0] spi_data, WriteDataM;
	logic [3:0] address;

	spi_slave spi_slave_instance(
		.SPI_CLK    (spi_clk),
		.SPI_CS     (spi_cs),
		.SPI_MOSI   (spi_mosi),
		.SPI_MISO   (spi_miso),
		.Data_Addr  (address),
		.Data_WE    (writeE),
		.Data_Write (WriteDataM),
		.Data_Read  (spi_data),
		.Clk        (CLOCK_50)
	);
	
	assign spi_clk  		= GPIO_0_PI[11];	// SCLK = pin 16 = GPIO_11
	assign spi_cs   		= GPIO_0_PI[9];	// CE0  = pin 14 = GPIO_9
	assign spi_mosi     	= GPIO_0_PI[15];	// MOSI = pin 20 = GPIO_15
	
	assign GPIO_0_PI[13] = spi_cs ? 1'bz : spi_miso;  // MISO = pin 18 = GPIO_13
	
	
//==============================	
// READ/WRITE LOGIC
//==============================	
	typedef enum logic [3:0]{S0,S1,S2, S3, S4, S5, S6, S7, S8, S9, S10} statetype;
	statetype state, nextstate;
	always_ff @(posedge clk2) begin
		state <= nextstate;
		if(writeEncoderR)begin
			address <= 4'h0;
			writeE <=1;
			WriteDataM <= wheel_right;
		end
		else if(writeEncoderL)begin
			address <= 4'h1;
			writeE <=1;
			WriteDataM <= wheel_left;
		end
		else if(readLED) begin
			address <=4'h0;
			writeE <= 0;
			LED <= 8'b01000000;
		end
		else if(writeLaser) begin
			address <= 4'h2;
			writeE <=1;
			WriteDataM <= laser;
		end
		else if(writeOdoLeft) begin
			address <= 4'h3;
			writeE <=1;
			WriteDataM <= odo_left;
		end
		else if(writeOdoRight) begin
			address <= 4'h4;
			writeE <=1;
			WriteDataM <= odo_right;
		end
		else if(writeUSwitch) begin
			address <= 4'h5;
			writeE <= 1;
			WriteDataM <= 2*microswitchR+microswitchL;
		end
		else if(writeSonar1) begin
			address <= 4'h6;
			writeE <= 1;
			WriteDataM <= distance1;
		end
		else if(writeSonar2) begin
			address <= 4'h7;
			writeE <= 1;
			WriteDataM <= distance2;
		end
		else if(writeSonar3) begin
			address <= 4'h8;
			writeE <= 1;
			WriteDataM <= distance3;
		end
		else if(writeSonar4) begin
			address <= 4'h9;
			writeE <= 1;
			WriteDataM <= distance4;
		end

	end
	
//==============================	
//NEXTSTATE LOGIC
//==============================	
	logic writeOdoLeft,writeOdoRight,writeEncoderR, writeEncoderL, readLED, writeLaser, writeUSwitch, writeSonar1,writeSonar2,writeSonar3,writeSonar4;
	always_comb begin
		// Default value
		nextstate = state;
		writeEncoderR = 0;
		writeEncoderL = 0;
		writeOdoLeft = 0;
		writeOdoRight = 0;
		readLED = 0;
		writeLaser = 0;
		writeUSwitch = 0;
		writeSonar1 = 0;
		writeSonar2 = 0;
		writeSonar3 = 0;
		writeSonar4 = 0;
		case (state)
		S0 : begin
				  nextstate = S1;
				  writeEncoderR = 1;
			  end
		S1 : begin
				nextstate = S2;
				writeEncoderL = 1;
			  end
		S2	: begin
				  nextstate = S3;
				  readLED = 1;
			  end
		S3 : begin
				  nextstate = S4;
				  writeLaser = 1;
			  end
		S4 : begin
				  nextstate= S5;
				  writeOdoLeft = 1;
			  end
		S5 : begin
				  nextstate = S6;
				  writeOdoRight = 1;
			  end
	   S6 : begin
				  nextstate = S7;
				  writeUSwitch =1;
			  end
	   S7 : begin
				  nextstate = S8;
				  writeSonar1 = 1;
			end
	   S8 : begin
			  nextstate = S9;
			  writeSonar2 = 1;
		    end
	   S9 : begin
				  nextstate = S10;
				  writeSonar3 = 1;
			end
	   S10 : begin
				  nextstate = S0;
				  writeSonar4 = 1;
			end
		default: nextstate = S0;
		endcase
	end
	
//==============================	
//CALL TO OUTSIDE MODULE
//==============================
	logic dir1, dir2;
	logic [31:0] laser;
	clock_reduce clock_reduce_3(CLOCK_50,reduce3, clk2);
	clock_reduce clock_reduce(CLOCK_50,reduce, clk);
	wheel_count wheel_count_left(.clk(CLOCK_50),.rst(KEY[0]), .codeA(codeAL), .codeB(codeBL),.count(wheel_left));
	wheel_count wheel_count_right(.clk(CLOCK_50),.rst(KEY[0]), .codeA(codeAR), .codeB(codeBR),.count(wheel_right));
	wheel_count wheel_odo_left(.clk(CLOCK_50), .rst(KEY[0]), .codeA(odoAL), .codeB(odoBL), .count(odo_left));
	wheel_count wheel_odo_right(.clk(CLOCK_50), .rst(KEY[0]), .codeA(odoAR), .codeB(odoBR), .count(odo_right));
	laser_count laser_count(.clk(CLOCK_50),.Opto(GPIO_1[7]),.Laser(GPIO_1[8]), .codeA(GPIO_1[4]), .codeB(GPIO_1[5]),.count(laser));
	logic [31:0] count;
	//assign LED[0] = dir1;
	//assign LED[1] = dir2;
	
	//SONAR
	
	
sonar sonar1(CLOCK_50, KEY[0], GPIO_1[9], GPIO_1[11], distance1);
sonar sonar2(CLOCK_50, KEY[0], GPIO_1[2], GPIO_1[4], distance2);
sonar sonar3(CLOCK_50, KEY[0], GPIO_1[7], GPIO_1[6], distance3);
sonar sonar4(CLOCK_50, KEY[0], GPIO_1[3], GPIO_1[5], distance4);
//DYNAMIXEL

	logic write_d, read_d; 
	logic [31:0] data_OUT, data_IN, data1, data2;
	logic [7:0] checksum;
	


/*stepper gripper(.clk(CLOCK_50),
					 .dir(GPIO_1[5]),
					 .step(GPIO_1[7]));*/	

endmodule



